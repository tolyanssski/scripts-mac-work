# AGENTS: базовые ожидания по задачам

Этот файл — шпаргалка по типовым требованиям во всех git-проектах в `~/projects`. Пользуйся им как стартовой инструкцией и дополняй под новую задачу.

## Работа с миграциями

Несмотря на то, что в проектах используются ORM-системы (либо ent, либо gorm), миграции у нас все ручные в виде простых SQL-файлов для Postgres.
У некоторых проектов есть своя БД, и соответственно своя папка migrations (лежит всегда в корне проекта), 
куда надо складывать новые файлы с миграциями. Если в проекте используется Atlas,
то нужно сгенерировать atlas.sum.

Но также есть проекты, у которых своей БД нет (используется общая), и миграции лежат
в отдельном git-проекте.
Если ты работаешь над таким проектом и тебе требуется сделать миграцию, но в проекте нет папки migrations (в корне проекта), просто создай новую папку migrations и
добавь туда SQL-файл. Я потом сам руками ее перенесу куда надо.

В проектах нужно создавать только UP-миграции. Миграций "down" (отката сделанных изменений) создавать не нужно.

### Формат файла миграций

Миграции складываются в папку migrations в корне проекта. Формат: SQL-файл,
с именем в формате `<YYYYMMDDhhmmss>_<названиеМиграцииНаАнгл>.sql`. Где `<YYYYMMDDhhmmss>` - текущее дата/время в заданном формате, например: 20260114090857 (пример для текущего даты/времени 2025-01-14 09:08:57).

### В каких случаях требуется создание новой миграции

Если в задаче ничего не написано про миграции, но при этом выполнение задачи
подразумевает создание новой или изменение существующей ORM-сущности (в ent/gorm),
всегда делай новую миграцию с этими изменениями, в соответствии с инструкцией выше. 

## Общие подходы
- Всегда обновляй сущности вместе с инфраструктурой: поля в ent/gorm + миграции Postgres, правки репозиториев, DTO, сервисных слоев, OpenAPI/gRPC, тестов и данных (data-migration скрипты, если нужно проставить значения старым строкам).
- Конфиги с secrets/creds/external_urls дублируй env-переменными: значения должны идти из YAML, но переопределяться через переменные окружения. Данный пункт касается только значений конфига, содержащих те или иные credentials для подключения к внешним системам (secret key, api key, external_system_url и аналогичные). 
- Локи обязательны при гонках: ключи строятся из сервиса/метода и бизнес-идентификаторов (userID, accountID, address и т.п.), TTL ставят только если явно указано.
- Побочные эффекты (Kafka producing, отправка e-mail/SMS, создание/отправка уведомлений) выноси из БД-транзакций; ошибки уведомлений чаще логируются и не прерывают основной флоу.

## OpenAPI / gRPC
- Ошибки: схемы `Error` выносятся в components, в ответах делаем `$ref`, описания/контент остаются inline. Пустые 200-ответы — схема `Empty`. Это требование повторяется во всех сервисах.
- Перенос `*Request`/`*Response` в `components/schemas`, content inline; теги у методов могут быть переопределены одним значением (Partnership и др.).
- Опциональные поля: если из сервисов приходит пустая строка, в ответе отдаём unset/null. Новые поля в запросах/ответах нужно пробрасывать до бизнес-слоя.
- gRPC методы добавляем вместе с proto-структурами и реализацией сервера; зависимости протягиваем через DI.

## Работа с сущностями
- Новые поля: задавай дефолты как в постановке, помни про связанные журналы (например, TransactionJournal). В гугланговых моделях соблюдай nullable/optional типы.
- Новые сущности: полный CRUD в репозиториях, миграции в `migrations`, без FK/edges если явно не просили. Для master_key_id/уникальных индексов делаются отдельные data/DDL-миграции.

## Логи и мониторинг
- Логируй ключевые действия и ошибки, но многие ошибки уведомлений/балансов не должны прерывать поток.
- Для Kafka-консумеров в логах ошибок добавляй список топиков.
- HTTP-серверы: middleware на логирование возврата ошибочных статусов.
- Метрики: есть обертки над Victoria Metrics; отправка готовых метрик с лейблами (в т.ч. accountID).

## Документация/тон
- README/описания иногда требуются с легким сарказмом и дружелюбным тоном. Схемы/диаграммы включаются в README, файлы кладутся в корень, ссылки добавляются в текст.

Если новая задача похожа на один из кейсов выше — применяй соответствующий набор действий без повторных подсказок.
