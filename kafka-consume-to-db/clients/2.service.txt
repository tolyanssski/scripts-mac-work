

1. Создай новый пакет internal/clients. В пакете clients создай config.yaml, в котором задай groupID и topic из которого будут читаться сообщения из Kafka. Реализуй отдельную функцию, которая парсит yaml-конфиг в структуру clients.Config. Сам yaml-файл должен быть embedded. 

2. Создай основную структуру нового сервиса: clients.Clients. Сгенерируй конструктор, через который в DI пробрось в структур зависимостями логгер, kafkaConsumer, repository и конфиг. При этом для логгера и репозитория создай локальные интерфейсы в пакете clients: у логгера методы нужные для записи в лог, а у репозитория CRUD-методы для работы с сущностью ent.Mt5Client.

3. Создай публичный метод Run(), в которой слушать сообщения из Кафки, получаемые сообщения парсить в dto.MtClientsMessage и пробрасывать в новый приватный метод processMessage(ctx, message). При этом Run() должен вернуть error если ошибка вернулась из консумера (то есть работать синхронно).

Пример того как использовать kafkaConsumer (взят из другого сервиса, сделай по аналогии, адаптируй под текущую задачу):

func (k *KYC) Run(ctx context.Context) error {
	return k.kafkaConsumer.Run(
		ctx,
		k.conf.Kafka.ConsumerGroupID,
		k.Topics(),
		func(ctx context.Context, message consumer.Message) error {
			select {
			case <-ctx.Done():
				return ctx.Err()
			default:
			}
			var e dto.KycEvent
			err := json.Unmarshal(message.Content, &e)
			if err != nil {
				k.log.Errorf("cannot unmarshal JSON message: %v", err.Error())
				return nil
			}

			e.Topic = message.Topic

			return k.Event(ctx, &e)
		},
	)
}

4. В приватном методе-обработчике сообщения dto.MtClientsMessage проверяй сначала два поля: type и action. Если type != "order" - сразу завершай обработку без ошибок. Продолжай обработку сообщения только если тип равен "order". Далее проверяй поле action: оно может быть одним из трех значений: add, update, delete. 
 - Если add: создаешь новые инстансы сущности ent.Mt5Client из элементов массива records, сохраняешь в репозиторий при помощи вызова Create. 
 - Если update: По каждому элементу в records: проверяешь наличие инстанса сущности в БД по ее ID (что соответствует полю Client в dto). Если такой нет, то делаешь Create, а если уже есть то делаешь Update с новыми пришедшими данными.
 - Если delete: По каждому элементу в records: проверяешь наличие инстанса сущности в БД по ее ID (что соответствует полю Client в dto). Если такой нет, то делаешь Create и затем сразу Delete (одной транзакцией в БД!), а если уже есть то делаешь Delete.

5. В новом сервисе сделай публичны метод для получения данных (при необходимости добавляй недостающие методы поиска в репозитории). Метод должен называться Clients(), на вход принимать список ClientIDs ([]int), в реализации преобразуй список []string и делай поиск в репозитории по списку из значений поля RecordID. Все позиции, которые найдены в БД по списку логинов и не удаленные, верни из сервисного метода в виде dto.